layout(local_size_x=_NBL_GLSL_WORKGROUP_SIZE_, local_size_y=1, local_size_z=1) in;

// Input Descriptor
layout(set=0, binding=0) uniform sampler2D inputImage;
#define _NBL_GLSL_EXT_FFT_INPUT_DESCRIPTOR_DEFINED_

#include <nbl/builtin/glsl/math/complex.glsl>
nbl_glsl_complex nbl_glsl_ext_FFT_getPaddedData(in ivec3 coordinate, in uint channel) 
{
	const ivec2 inputImageSize = textureSize(inputImage, 0);
	const vec2 rcp = vec2(1.f)/(vec2(inputImageSize)*KERNEL_SCALE);
	const vec2 normalizedCoords = (vec2(coordinate.xy)+vec2(0.5f))*rcp;
	vec2 uv = normalizedCoords+vec2(0.5-0.5/KERNEL_SCALE);

	const float lod = -log2(KERNEL_SCALE);
	vec4 texelValue_lo = textureLod(inputImage, uv, lod);
	const uint nextAxis = 0u; // TODO: index
	uv[nextAxis] += rcp[nextAxis];
	vec4 texelValue_hi = textureLod(inputImage, uv, lod);

	return nbl_glsl_complex(texelValue_lo[channel],0.f);
}
#define _NBL_GLSL_EXT_FFT_GET_PADDED_DATA_DEFINED_

void nbl_glsl_ext_FFT_setData(in uvec3 coordinate, in uint channel, in nbl_glsl_complex complex_value);
#define _NBL_GLSL_EXT_FFT_SET_DATA_DEFINED_


#include "nbl/builtin/glsl/ext/FFT/default_compute_fft.comp"

void nbl_glsl_ext_FFT_setData(in uvec3 coordinate, in uint channel, in nbl_glsl_complex complex_value)
{
	const uint index = nbl_glsl_dot(uvec4(coordinate,channel),nbl_glsl_ext_FFT_Parameters_t_getOutputStrides());
	nbl_glsl_ext_FFT_storage_t_set(outData[index],complex_value);
}